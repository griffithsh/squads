// Code generated by "enumer -type=DirectionType,RelativeDirection -json"; DO NOT EDIT.

package geom

import (
	"encoding/json"
	"fmt"
	"strings"
)

const _DirectionTypeName = "NNESESSWNW"

var _DirectionTypeIndex = [...]uint8{0, 1, 3, 5, 6, 8, 10}

const _DirectionTypeLowerName = "nnesesswnw"

func (i DirectionType) String() string {
	if i < 0 || i >= DirectionType(len(_DirectionTypeIndex)-1) {
		return fmt.Sprintf("DirectionType(%d)", i)
	}
	return _DirectionTypeName[_DirectionTypeIndex[i]:_DirectionTypeIndex[i+1]]
}

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the stringer command to generate them again.
func _DirectionTypeNoOp() {
	var x [1]struct{}
	_ = x[N-(0)]
	_ = x[NE-(1)]
	_ = x[SE-(2)]
	_ = x[S-(3)]
	_ = x[SW-(4)]
	_ = x[NW-(5)]
}

var _DirectionTypeValues = []DirectionType{N, NE, SE, S, SW, NW}

var _DirectionTypeNameToValueMap = map[string]DirectionType{
	_DirectionTypeName[0:1]:       N,
	_DirectionTypeLowerName[0:1]:  N,
	_DirectionTypeName[1:3]:       NE,
	_DirectionTypeLowerName[1:3]:  NE,
	_DirectionTypeName[3:5]:       SE,
	_DirectionTypeLowerName[3:5]:  SE,
	_DirectionTypeName[5:6]:       S,
	_DirectionTypeLowerName[5:6]:  S,
	_DirectionTypeName[6:8]:       SW,
	_DirectionTypeLowerName[6:8]:  SW,
	_DirectionTypeName[8:10]:      NW,
	_DirectionTypeLowerName[8:10]: NW,
}

var _DirectionTypeNames = []string{
	_DirectionTypeName[0:1],
	_DirectionTypeName[1:3],
	_DirectionTypeName[3:5],
	_DirectionTypeName[5:6],
	_DirectionTypeName[6:8],
	_DirectionTypeName[8:10],
}

// DirectionTypeString retrieves an enum value from the enum constants string name.
// Throws an error if the param is not part of the enum.
func DirectionTypeString(s string) (DirectionType, error) {
	if val, ok := _DirectionTypeNameToValueMap[s]; ok {
		return val, nil
	}

	if val, ok := _DirectionTypeNameToValueMap[strings.ToLower(s)]; ok {
		return val, nil
	}
	return 0, fmt.Errorf("%s does not belong to DirectionType values", s)
}

// DirectionTypeValues returns all values of the enum
func DirectionTypeValues() []DirectionType {
	return _DirectionTypeValues
}

// DirectionTypeStrings returns a slice of all String values of the enum
func DirectionTypeStrings() []string {
	strs := make([]string, len(_DirectionTypeNames))
	copy(strs, _DirectionTypeNames)
	return strs
}

// IsADirectionType returns "true" if the value is listed in the enum definition. "false" otherwise
func (i DirectionType) IsADirectionType() bool {
	for _, v := range _DirectionTypeValues {
		if i == v {
			return true
		}
	}
	return false
}

// MarshalJSON implements the json.Marshaler interface for DirectionType
func (i DirectionType) MarshalJSON() ([]byte, error) {
	return json.Marshal(i.String())
}

// UnmarshalJSON implements the json.Unmarshaler interface for DirectionType
func (i *DirectionType) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return fmt.Errorf("DirectionType should be a string, got %s", data)
	}

	var err error
	*i, err = DirectionTypeString(s)
	return err
}

const _RelativeDirectionName = "ForwardBehindForwardLeftForwardRightBackLeftBackRight"

var _RelativeDirectionIndex = [...]uint8{0, 7, 13, 24, 36, 44, 53}

const _RelativeDirectionLowerName = "forwardbehindforwardleftforwardrightbackleftbackright"

func (i RelativeDirection) String() string {
	if i < 0 || i >= RelativeDirection(len(_RelativeDirectionIndex)-1) {
		return fmt.Sprintf("RelativeDirection(%d)", i)
	}
	return _RelativeDirectionName[_RelativeDirectionIndex[i]:_RelativeDirectionIndex[i+1]]
}

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the stringer command to generate them again.
func _RelativeDirectionNoOp() {
	var x [1]struct{}
	_ = x[Forward-(0)]
	_ = x[Behind-(1)]
	_ = x[ForwardLeft-(2)]
	_ = x[ForwardRight-(3)]
	_ = x[BackLeft-(4)]
	_ = x[BackRight-(5)]
}

var _RelativeDirectionValues = []RelativeDirection{Forward, Behind, ForwardLeft, ForwardRight, BackLeft, BackRight}

var _RelativeDirectionNameToValueMap = map[string]RelativeDirection{
	_RelativeDirectionName[0:7]:        Forward,
	_RelativeDirectionLowerName[0:7]:   Forward,
	_RelativeDirectionName[7:13]:       Behind,
	_RelativeDirectionLowerName[7:13]:  Behind,
	_RelativeDirectionName[13:24]:      ForwardLeft,
	_RelativeDirectionLowerName[13:24]: ForwardLeft,
	_RelativeDirectionName[24:36]:      ForwardRight,
	_RelativeDirectionLowerName[24:36]: ForwardRight,
	_RelativeDirectionName[36:44]:      BackLeft,
	_RelativeDirectionLowerName[36:44]: BackLeft,
	_RelativeDirectionName[44:53]:      BackRight,
	_RelativeDirectionLowerName[44:53]: BackRight,
}

var _RelativeDirectionNames = []string{
	_RelativeDirectionName[0:7],
	_RelativeDirectionName[7:13],
	_RelativeDirectionName[13:24],
	_RelativeDirectionName[24:36],
	_RelativeDirectionName[36:44],
	_RelativeDirectionName[44:53],
}

// RelativeDirectionString retrieves an enum value from the enum constants string name.
// Throws an error if the param is not part of the enum.
func RelativeDirectionString(s string) (RelativeDirection, error) {
	if val, ok := _RelativeDirectionNameToValueMap[s]; ok {
		return val, nil
	}

	if val, ok := _RelativeDirectionNameToValueMap[strings.ToLower(s)]; ok {
		return val, nil
	}
	return 0, fmt.Errorf("%s does not belong to RelativeDirection values", s)
}

// RelativeDirectionValues returns all values of the enum
func RelativeDirectionValues() []RelativeDirection {
	return _RelativeDirectionValues
}

// RelativeDirectionStrings returns a slice of all String values of the enum
func RelativeDirectionStrings() []string {
	strs := make([]string, len(_RelativeDirectionNames))
	copy(strs, _RelativeDirectionNames)
	return strs
}

// IsARelativeDirection returns "true" if the value is listed in the enum definition. "false" otherwise
func (i RelativeDirection) IsARelativeDirection() bool {
	for _, v := range _RelativeDirectionValues {
		if i == v {
			return true
		}
	}
	return false
}

// MarshalJSON implements the json.Marshaler interface for RelativeDirection
func (i RelativeDirection) MarshalJSON() ([]byte, error) {
	return json.Marshal(i.String())
}

// UnmarshalJSON implements the json.Unmarshaler interface for RelativeDirection
func (i *RelativeDirection) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return fmt.Errorf("RelativeDirection should be a string, got %s", data)
	}

	var err error
	*i, err = RelativeDirectionString(s)
	return err
}
